format_string = """JTUyQyVzACUzLjFoTSUzLjBsRSUrMS4zbE0lMS40bGxTJTMuMWxNJTMuMmxPJS03
LjNDACUwLjQwOTZoaE0lMC4yNTVsbEklMS4wbE0lMS44bGxMJTAuMWxVJTEuMGxN
JTEuMTZsbEwlMC4xbFUlMS4yMDBsbE0lMi4xNzg4bGxNJTdDJS02MTQ0LjE3MDE3
MzYzMDJsbE0lMC4yMDBoaE0lMC4yNTVsbEklMC4zN2xsTyUwMjAwLjBDAAAAAAAA
AAAAAAAAAABxYHphZGRkODgZcWR6ZWdmZGQ4OBlxZ2djF3FkemQ4OBlxYWRkF3Fl
ZmJmF3FkYmFnemQXVHFlemQ4OBlUcWd6ZDgZcWd6ZjgacWRmYWd6ZxdxZnplODgH
cWd6ZjgZcWd6ZzgMcWd6ZDgbcWd6ZTg4G3F5ZmJlemcXVHF/YHpkOBlxYHpmODgH
VHFlemU4OBlxZnpmODgZcWZiZRdxf2dmZnplF3FkemU4OAdxZXplZ2JkZDg4GXFl
emQ4G3F/Z2djemUXVHFkemQ4OBlUcWR6Zjg4AlRxZHpnODgMcWR6ZTg4B1RxZXpk
OBlxZXpmODgacWRgZGF6ZRdxf2BlZ3plF3FgY2QXcWR6ZTg4B1RxZXpkOBlxZXpl
ODgbcWRnbWN6ZRdxf2BmbHplF1RxZnpkOBlxZnpgZG1iODgHcWB6ZjwZcWB6ZmFh
ODgdcX9hYGR6YBdUcWZ6ZDgZcWZ6Zjg4DHFmemFkZGQ4OAdxZnpmPBlxZnpmYWE4
OB1xYHpmOBFxZHplODgHcWZ6ZDgZcWBjZBdxYHpkOAdxYHpmYWE4OB1xZHpmOBlx
ZnplODgbcWZ6YGFkZDg4B3F/ZnpgOBlxYWRkF1RxZHplZmdgYWJjbG04OBlxZXpk
ODgZcWV6YGRtYjg4B3FlemU8GXFkemU4EXFmemQ4OBlxZnpsYGJjbGJsZWw4OAdx
ZnpkOBFxZXpkODgZcWV6YmVgYDg4B3F/ZXpmOBlxZXpgODgZcWV6YGRtYjg4B3Fl
emU8GXFkemU4EXFmemQ4OBlxZnplYGBnYWdsY2FtODgHcWZ6ZDgRcWV6YDg4GXFl
emJlYGA4OAdxf2V6ZjgZcWV6bDg4GXFlemBkbWI4OAdxZXplPBlxZHplOBFxZnpk
ODgZcWZ6ZWRgY2FlYWFlZDg4B3FmemQ4EXFlemw4OBlxZXpiZWBgODgHcX9lemY4
GXFlemVmODgZcWV6YGRtYjg4B3FlemU8GXFkemU4EXFmemQ4OBlxZnpnYW1gbW1h
ZWA4OAdxZnplY2ZgYGJlbGFiODgHcWZ6ZDgRcWV6ZWY4OBlxZXpiZWBgODgHcX9l
emY4GXFlemViODgZcWV6YGRtYjg4B3FlemU8GXFkemU4EXFmemQ4OBlxZnpmYGVk
ZmBkZ2E4OAdxZnpkOBFxZXplYjg4GXFlemJlYGA4OAdxf2V6ZjgZcWV6ZmQ4OBlx
ZXpgZG1iODgHcWV6ZTwZcWR6ZTgRcWZ6ZDg4GXFmemZmZmZiY2NmYDg4B3FmemQ4
EXFlemZkODgZcWV6YmVgYDg4B3F/ZXpmOBlxZXpmYDg4GXFlemBkbWI4OAdxZXpl
PBlxZHplOBFxZnpkODgZcWZ6bGBgZG1iZGVsODgHcWZ6ZDgRcWV6ZmA4OBlxZXpi
ZWBgODgHcX9lemY4GVRxZHpkODgZcWV6ZDg4GXFlemBhZGQ4OAdxZXplPBlxZnpk
ODgZcWZ6ZWdjYGFgZmJmYTg4B3FmemVibGJtZWFjZmQ4OAdxZnplZWZtYmxibGJk
ODgHcWV6ZjgRcWR6ZTgBcWV6YDg4GXFlemBhZGQ4OAdxZXplPBlxZnpkODgZcWZ6
bGBmZmVjZGZtODgHcWZ6ZWBsZ21kZmFiYDg4B3FlemY4EXFkemU4AXFlemw4OBlx
ZXpgYWRkODgHcWV6ZTwZcWZ6ZDg4GXFmemVsYmxkZWdjZ2U4OAdxZXpmOBFxZHpl
OAFxZXplZjg4GXFlemBhZGQ4OAdxZXplPBlxZnpkODgZcWZ6YWxgYm1gY2dmODgH
cWZ6ZWBhZ2dlZmNkZDg4B3FlemY4EXFkemU4AXFlemViODgZcWV6YGFkZDg4B3Fl
emU8GXFmemQ4OBlxZnpmZmdhYGxjYGA4OAdxZXpmOBFxZHplOAFxZXpmZDg4GXFl
emBhZGQ4OAdxZXplPBlxZnpkODgZcWZ6ZW1hbGxsZ2NmYjg4B3FmemVtZWJkZGxk
bW04OAdxZXpmOBFxZHplOAFxZXpmYDg4GXFlemBhZGQ4OAdxZXplPBlxZnpkODgZ
cWZ6ZWxmbW1nY2JkYTg4B3FmemVsZWFnYWJkbGI4OAdxZnpmYWdsZ2JibWw4OAdx
ZXpmOBFxZHplOAFU"""

import base64
import json
import hexdump
import ctypes

import sys
sys.setrecursionlimit(10000)

a52_ptr = 0x5080 
user_input_ptr = 0x6080
flag_ptr = 0x6880
stack_ptr = 0x70A0

VERBOSE = False

class VM:
    def __init__(self):
        self.memory = [0 for x in range(0x5080)]  + [x for x in base64.b64decode(format_string)] + [0 for x in range(0x5000)]
        self.instruction_count = 0

        # map from addr to list of instructions
        self.instruction_cache = dict()

    def run_with_input(self, input_str):
        for i in range(len(input_str)):
            self.memory[user_input_ptr + i] = ord(input_str[i])

        self.evaluate_addr(a52_ptr)
        return self.instruction_count

    def evaluate_addr(self, addr):
        if addr in self.instruction_cache:
            instructions = self.instruction_cache[addr]
        else:
            instructions = self.compile(addr)
            self.instruction_cache[addr] = instructions

        for inst in instructions:
            if VERBOSE:
                print(inst.dry_invoke())
            inst.invoke()
            self.instruction_count += 1

    def read_cstring(self, offset):
        s = ''
        while self.memory[offset] != 0:
            try:
                s += chr(self.memory[offset])
            except:
                print('ERROR at offset', hex(offset))
                print(hex(memory[offset]))
                # hexdump(memory[offset : offset+0x20])
                return s
            
            offset += 1
        return s

    def compile(self, offset):
        compiler = Compiler()
        return compiler.compile(self.read_cstring(offset), self)

class Flags:
    def __init__(self):
        self.char = False
        self.short = False
        self.double_long = False
        self.long = False
        self.left = False
        self.show_sign = False
        self.pad = ' '

    def __str__(self):
        on_flags = []
        for attr in dir(self):
            if attr.startswith('_') is False and getattr(self, attr) is True:
                on_flags.append(attr)

        return f'Flags[{" ".join(on_flags)}]'



class Compiler:
    def compile(self, fmt, vm):
        parts = fmt.split('%')[1:]
        instructions = []

        for part in parts:
            flags = Flags()

            prefix = part[0]
            if prefix == '+':
                flags.show_sign = True
                part = part[1:]
            if prefix == '-':
                flags.left = True
                part = part[1:]

            handler = part[-1]
            extra_flags = ''
            prec = 0
            width = 0

            part = part[:-1]

            while len(part) > 1 and part[-1].isdigit() is False:
                extra_flags += part[-1]
                part = part[:-1]

            if '.' in part:
                after = part.split('.')[1]
                prec = int(after)

            if 'll' in extra_flags:
                flags.double_long = True
            elif 'l' in extra_flags:
                flags.long = True

            if 'hh' in extra_flags:
                flags.char = True
            elif 'h' in extra_flags:
                flags.short = True

            ######################

            if len(part) >= 1:
                before = part.split('.')[0] # if no dot, will return one item
                if before.startswith('0'):
                    flags.pad = '0'

                width = int(before)

            factory = CmdFactory(vm) 

            inst = factory.build_cmd(handler, flags, width, prec) 
            instructions.append(inst)

        return instructions


class CmdFactory:
    def __init__(self, vm):
        self.vm = vm
        self.cmds = {
            'M': M_Cmd,
            'S': S_Cmd,
            'O': O_Cmd,
            'X': X_Cmd,
            'V': V_Cmd,
            'N': N_Cmd,
            'L': L_Cmd,
            'R': R_Cmd,
            'E': E_Cmd,
            'I': I_Cmd,
            'U': U_Cmd,
            'C': C_Cmd,
        }

    def build_cmd(self, cmd_name, flags, width, prec):
        if cmd_name == 's':
            return CmdPrintfS(self.vm)

        cmd = self.cmds[cmd_name]
        instance = cmd(self.vm, flags, width, prec)
        return instance

class CmdPrintfS:
    def __init__(self, vm):
        self.vm = vm

    def translate_cmd(self):
        return f'printf(%s)'

    def dry_invoke(self):
        s = self.vm.read_cstring(flag_ptr)
        return f'printf("%s", "{s}")'

    def invoke(self):
        print('print:', self.vm.read_cstring(flag_ptr))

class Cmd:
    op = "undefined-op"

    def __init__(self, vm, flags, width, prec):
        self.vm = vm
        self.flags = flags
        self.width = width
        self.prec = prec

    def get_addr(self, width):
        addr = None 
        if self.flags.left:
            addr = a52_ptr + width

        elif self.flags.show_sign:
            # a52[stack[width]]
            addr = a52_ptr + self.read_stack(width)

        if addr is None:
            addr = stack_ptr + (width*4)

        return addr

    def get_val(self, prec):
        val = 0
        if self.flags.char:
            val = self.read_a52(prec)

        elif self.flags.short:
            # a52[stack[prec]]
            val = self.read_a52(self.read_stack(prec))

        elif self.flags.double_long:
            val = prec

        elif self.flags.long:
            val = self.read_stack(prec)

        # print(f'get_val({prec}) = {val}')
        return val

    def translate_addr(self, width):
        if self.flags.left:
            return f"at52[{width}]"

        elif self.flags.show_sign:
            return  f"a52[stack[(int) {width}]]"

        return f"stack[(int) {width}]"

    def translate_val(self, prec):
        if self.flags.char:
            return f"a52[{prec}]"

        elif self.flags.short:
            return f"a52[stack[(int) {prec}]]"

        elif self.flags.double_long:
            return f"{prec}"

        elif self.flags.long:
            return f"stack[(int) {prec}]"

        return "0"

    def translate_cmd(self):
        return f"{self.translate_addr(self.width)} {self.op} {self.translate_val(self.prec)}"

    def write_mem(self, off, val):
        global memory
        self.vm.memory[off+0] = val & 0xff
        self.vm.memory[off+1] = (val & 0xff00) >> 8
        self.vm.memory[off+2] = (val & 0xff0000) >> 16 
        self.vm.memory[off+3] = (val & 0xff000000) >> 24 

    def read_mem(self, off): 
        global memory
        v1 = self.vm.memory[off]
        v2 = self.vm.memory[off+1] << 8 
        v3 = self.vm.memory[off+2] << 16 
        v4 = self.vm.memory[off+3] << 24 
        val = v1 + v2 + v3 + v4
        # return val & 0xffffffff
        orig = val
        cval = ctypes.c_int(val).value
        # if val & 1 << 31:
        #     val = ~val + 1

        # print(val, cval, 'origin:', orig)
        # assert(val == cval)
        # return val
        return cval

    def read_stack(self, off):
        return self.read_mem(stack_ptr + (off*4))

    def read_a52(self, off):
        return self.read_mem(a52_ptr+off)


class GenericCommand(Cmd):
    operation = None
    def __init__(self, vm, flags, width, prec):
        super().__init__(vm, flags, width, prec)

    def invoke(self):
        assert(self.operation is not None)
        addr = self.get_addr(self.width)
        val = self.get_val(self.prec)

        addr_val_before = self.read_mem(addr)
        result = self.operation(addr_val_before, val)
        self.write_mem(addr, result)

    def dry_invoke(self):
        addr = self.get_addr(self.width)
        val_before = self.read_mem(addr)
        val = self.get_val(self.prec)
        return f'{self.translate_addr(self.width)} = ({self.op}, {val_before}, {val})'

    def __str__(self):
        return f'{self.translate_cmd()}'


class M_Cmd(Cmd):
    """ assign """
    op = "="
    def invoke(self):
        addr = self.get_addr(self.width)
        val = self.get_val(self.prec)
        self.write_mem(addr, val)

    def __str__(self):
        return self.translate_cmd()

    def dry_invoke(self):
        val = self.get_val(self.prec)
        return f'{self.translate_addr(self.width)} = {val}'


class S_Cmd(GenericCommand):
    op = "+="
    operation = staticmethod(lambda x,y: x+y)
    
class O_Cmd(GenericCommand):
    """ minus """
    op = "-="
    operation =  staticmethod(lambda x,y: x-y)

class X_Cmd(GenericCommand):
    """ mult """
    op = "*="
    operation =  staticmethod(lambda x,y: x*y)

class V_Cmd(GenericCommand):
    """ div """
    op = "/="
    operation =  staticmethod(lambda x,y: x//y)

class N_Cmd(GenericCommand):
    """ modulu """
    op = "%="
    operation =  staticmethod(lambda x,y: x%y)

class L_Cmd(GenericCommand):
    """ shift left """
    op = "<<="
    operation =  staticmethod(lambda x,y: x << y)

class R_Cmd(GenericCommand):
    """ shift right """
    op = ">>="
    operation =  staticmethod(lambda x,y: x >> y)

class E_Cmd(GenericCommand):
    """ xor """
    op = "^="
    operation =  staticmethod(lambda x,y: x^y)

class I_Cmd(GenericCommand):
    """ and """
    op = "&="
    operation =  staticmethod(lambda x,y: x&y)

class U_Cmd(GenericCommand):
    """ or """
    op = "|="
    operation =  staticmethod(lambda x,y: x|y)

class C_Cmd(Cmd):
    """ Conditional """
    op = "conditional"

    def translate_jmp_type(self):
        if self.flags.left:
            return 'C.lt'
        if self.flags.show_sign:
            return 'C.gt'
        if self.flags.pad != '0':
            return 'C.always'
        return 'C.eq'

    def translate_cmd(self):
        if self.flags.left:
            return f'C.lt {self.width} stack[(int) {self.prec}] < 0'
        if self.flags.show_sign:
            return f'C.gt {self.width} stack[(int) {self.prec}] > 0'
        if self.flags.pad != '0':
            return f'C.always {self.width}'
        return f'C.eq {self.width} stack[(int) {self.prec}] == 0'
    
    def dry_invoke(self):
        jmp_type = self.translate_jmp_type()
        if jmp_type == 'C.always':
            return f'{jmp_type} #{self.width}'

        val = self.read_stack(self.prec)
        return f'{jmp_type} #{self.width} {val} 0'

    def __str__(self):
        return self.translate_cmd()

    def invoke(self):
        jmp = False

        if self.flags.left:
            val = self.read_stack(self.prec)
            jmp = val < 0

        elif self.flags.show_sign:
            jmp = self.read_stack(self.prec) > 0
        else: 
            if self.flags.pad != '0':
                jmp = True
            else:
                jmp = self.read_stack(self.prec) == 0

        if jmp:
            self.vm.evaluate_addr(self.width + a52_ptr)

import itertools
def main():
    if len(sys.argv) < 2:
        print(f'Usage: ./{sys.argv[0]} flag')
        return

    vm = VM()
    op_count = vm.run_with_input(sys.argv[1])
    print(f'executed {op_count} ops')

    # s = vm.read_cstring(a52_ptr + 6144)
    # print('flag:', s)

    # print("========================")
    # vm.evaluate_addr(a52_ptr + 653)

    # for addr, instructions in sorted(vm.instruction_cache.items()):
    #     addr -= a52_ptr
    #     print(f'\n========== {addr} ==========')
    #     for inst in instructions:
    #         print(inst.translate_cmd())


if __name__ == '__main__':
    # run python3 ./vm.py TheNewFlagHillsByTheCtfWoods
    # flag is CTF{curs3d_r3curs1ve_pr1ntf}
    main()
